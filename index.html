<!DOCTYPE html>
<html>

<head>
	<title>Camloco - fun camera effects</title>
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black">
	<meta name="apple-mobile-web-app-title" content="Camloco Web">
	<link rel="apple-touch-icon" href="images/apple-touch-icon-iphone-60x60.png">
	<link rel="apple-touch-icon" sizes="60x60" href="images/apple-touch-icon-ipad-76x76.png">
	<link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-iphone-retina-120x120.png">
	<link rel="apple-touch-icon" sizes="144x144" href="images/apple-touch-icon-ipad-retina-152x152.png">
	<link href="css/index.css" rel="stylesheet" />
	<link rel="manifest" href="manifest.json">
	<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
	<script type="text/javascript" src="canvas2image.js"></script>
	<script type="text/javascript" src="webgl-utils.js"></script>
	<script src="js/recorderjs/recorder.js"></script>
	<script src="js/raphael-min.js"></script>
	<script type="text/javascript" src="main.js"></script>
	<link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon">

	<script id="shader-1-fs" type="f">
precision highp float;
varying vec2 vTextureCoord;
uniform sampler2D texture0;
uniform vec2 resolution;
uniform vec2 mouse;
uniform int index;
uniform float time;
uniform float Param1;
uniform float Param2;
uniform float Param3;
#define PI	3.14159265359
#define PI2	( PI * 2.0 )

const mediump float Tau	= 6.2832;
struct Mesh
{
  vec3 a;
  vec3 b;
  vec3 c;
  vec3 d;
};

vec2 rotate( in vec2 p, in float t )
{
	return p * cos( -t ) + vec2( p.y, -p.x ) * sin( -t );
}

vec3 rotate( in vec3 p, in vec3 t )
{
  p.yz = rotate( p.yz, t.x );
  p.zx = rotate( p.zx, t.y );
	p.xy = rotate( p.xy, t.z );
  return p;
}

Mesh rotate( in Mesh m, in vec3 t )
{
  m.a = rotate(m.a, t);
  m.b = rotate(m.b, t);
  m.c = rotate(m.c, t);
  m.d = rotate(m.d, t);
  return m;
}

float castRay( in vec3 ro, in vec3 rd, in Mesh m, out vec3 p)
{
  float z = 10.0;
  vec3 n = cross( m.c - m.a, m.b - m.a );
  float t = dot( m.a - ro, n ) / dot( rd, n );
  if ( t > 0.0 )	{
  	p = ro + rd * t;
      if ( dot( cross( m.b - m.a, n ), p - m.a ) > 0.0 )
      if ( dot( cross( m.c - m.b, n ), p - m.b ) > 0.0 )
      if ( dot( cross( m.d - m.c, n ), p - m.c ) > 0.0 )
      if ( dot( cross( m.a - m.d, n ), p - m.d ) > 0.0 ) z = t;
  }
  return z;
}

vec2 getUV(in Mesh m, in vec3 p)
{
	vec3 ap = p - m.a;
  vec3 bp = p - m.b;
  vec3 dp = p - m.d;
  vec3 ab = m.b - m.a;
  vec3 ad = m.d - m.a;
  float x0 = dot( bp, ab );
  float x1 = dot( ap, ab );
	float y0 = dot( dp, ad );
  float y1 = dot( ap, ad );
  return vec2( x0 / ( x0 - x1 ), y0 / ( y0 - y1 ) );
}

Mesh genQuad( in vec3 center, in float width, in float height)
{
 	return Mesh(
    center + vec3(  width,  height, 0.0) * 0.5,
    center + vec3( -width,  height, 0.0) * 0.5,
    center + vec3( -width, -height, 0.0) * 0.5,
    center + vec3(  width, -height, 0.0) * 0.5);
}

Mesh quads( in int i )
{
  float t = time;
	if ( i == 0)
    return  rotate( genQuad( vec3( 0.2, 0.1, -1.0 ), 1.0, 1.0 ),  vec3( 0.0, 0.5, 0.3 ) * time);
	if ( i < 11) t *= -1.0;
	return  rotate( genQuad(
    	vec3( 3.0 * sin( float( i ) * PI2 / 10.0 + t * 0.3 ),
    		  0.1,
    		  3.0 * cos( float( i ) * PI2 / 10.0 + t * 0.3 ) - 3.0
    	), 1.0, 1.0 ),
		vec3( 0.2, 0.0, 0.8 * sin( t * 0.2 ) ) );
}


vec2 tileSize = vec2(128,128);

const float speed = 0.5;
const float tileAfterTileSpeed = 10.0;
const float checkerDistance = 0.015;

bool flipX = true;
bool flipY = true;

const bool preTileSingleColor = false; ///8bit ftw
const bool postTileSingleColor = false; ///8bit ftw

vec2 tile2Global(vec2 tex, vec2 tileNum, bool tileSingleColor) {
    vec2 perTile = tileSize / resolution;
    return tileNum * perTile + (tileSingleColor ? vec2(0) : tex*perTile);
}

void main(void) {
  vec2 cent = vec2(0.5, 0.5);
  vec2 tx = 1.0-gl_FragCoord.xy / resolution;
  float pr = Param3;
//  pr = clamp(pr,0.,1.);

  if (index == 6) { // just change colour
  }
  else if (index == 1) { // moving squares
	  tx = ( 2.0 * gl_FragCoord.xy - resolution ) / resolution.y;
    tx.y = 1.0-tx.y;
    vec3 rd =normalize( vec3( tx, -1.8 ) );
	  vec3 ro = vec3( 0.0, 0.0, 1.5 );
    float z = 10.0;
    vec3 col = vec3(0.0);
    for (int i = 1; i < 21; i++ ) {
    	Mesh m = quads( i );
    	vec3 pos;
    	float t = castRay(ro, rd, m, pos);
    	if ( z > t ) 	{
      	tx = getUV( m, pos );
        if ( i > 10 )
          tx.x = 1.0 - tx.x;
        col = texture2D(texture0, tx).rgb;
      	if ( !( col.r < 0.4 && col.g > 0.35 && col.b < 0.4 ) )
          z = t;
    	}
    }
    vec3 rgb2 = vec3((col.r+col.g+col.b)/3.0);
    col.xyz = vec3(mix(rgb2, col.xyz, min(pr,1.)));
    gl_FragColor = vec4(col, 1.0);
    return;
  }
  else if (index == 0) {
	  vec2 p = ( 2.0 * gl_FragCoord.xy - resolution.xy ) / resolution.y;
    vec3 rd =normalize( vec3( p, -.8 ) );
	  vec3 ro = vec3( 0.0, 0.0, 1.5 );
    float z = 10.0;
    vec3 col = vec3(0.0);
    for (int i = 2; i < 20; i++ ) {
    	Mesh m = quads( i );
    	vec3 pos;
    	float t = castRay(ro, rd, m, pos);
    	if ( z > t ) 	{
      	tx = getUV( m, pos );
      	tx.y = 1.0-tx.y;
        if ( i > 10 )
          tx.x = 1.0 - tx.x;
    	}
    }
  }
  else if (index < 6) { // tiles
//  	tx = gl_FragCoord.xy / resolution;
    vec4 fragColor = vec4(0., 0., 0., 0.);
    if (index == 2) {
      tileSize = vec2(64,128);
      flipX = false;
    }
    if (index == 3) {
      tileSize = vec2(128,128);
      flipY = false;
    }
    if (index == 4) {
      tileSize = vec2(64,64);
    }
    vec2 posInTile = mod(vec2(gl_FragCoord), tileSize);
    vec2 tileNum = floor(vec2(gl_FragCoord)/ tileSize);
    int num = int(tileNum.x);
    vec2 totalTiles = ceil(resolution / tileSize);
    float countTiles = totalTiles.x * totalTiles.y;

	  vec2 perTile = ceil(tileSize / resolution);
    float offset = 0.0;   //curtain
    //   scanline horizontal
    offset = (tileNum.x + tileNum.y * totalTiles.x) / countTiles;
    //   and scanline vertical ofc
    //offset = (tileNum.y + tileNum.x * totalTiles.y) / countTiles;

    float timeOffset = time * speed - offset * tileAfterTileSpeed;
	// if you want to stop the animation ...
    //timeOffset = clamp(timeOffset, 0.0, 0.5);
    float sinTime = 1.0 - abs(cos(fract(timeOffset) * 3.1415926));

//    fragColor.rg = tx;
//    fragColor.b = sinTime;

    vec2 texC = posInTile / tileSize;

    if (sinTime <= 0.5){

    if (flipX) {
        if ((texC.x < sinTime) || (texC.x > 1.0 - sinTime)){
            discard;
        }
        if (texC.x < 0.5) {
            texC.x = (texC.x - sinTime) * 0.5 / (0.5 - sinTime);
        } else {
            texC.x = (texC.x - 0.5) * 0.5 / (0.5 - sinTime) + 0.5;
        }
    }

    if (flipY) {
        if ((texC.y < sinTime) || (texC.y > 1.0 - sinTime)){
            discard;
        }
        if (texC.y < 0.5) {
            texC.y = (texC.y - sinTime) * 0.5 / (0.5 - sinTime);
        } else {
            texC.y = (texC.y - 0.5) * 0.5 / (0.5 - sinTime) + 0.5;
        }
    }

    } else {
      if (flipX) {
          if ((texC.x > sinTime) || (texC.x < 1.0 - sinTime)){
              discard;
          }
          if (texC.x < 0.5) {
              texC.x = (texC.x - sinTime) * 0.5 / (0.5 - sinTime);
          } else {
              texC.x = (texC.x - 0.5) * 0.5 / (0.5 - sinTime) + 0.5;
          }
          texC.x = 1.0 - texC.x;
      }

      if (flipY) {
          if ((texC.y > sinTime) || (texC.y < 1.0 - sinTime)){
              discard;
          }
          if (texC.y < 0.5) {
              texC.y = (texC.y - sinTime) * 0.5 / (0.5 - sinTime);
          } else {
              texC.y = (texC.y - 0.5) * 0.5 / (0.5 - sinTime) + 0.5;
          }
          texC.y = 1.0 - texC.y;
      }

    }
    fragColor = texture2D(texture0, 1.0-tile2Global(texC, tileNum, preTileSingleColor));
    vec3 rgb2 = vec3((fragColor.r+fragColor.g+fragColor.b)/3.0);
    fragColor.xyz = vec3(mix(rgb2, fragColor.xyz, min(pr,1.)));
    gl_FragColor = fragColor;
    return;
  }
  else if (index == 7) {
    if (tx.x < 0.5)
    		tx.x = 1.0-tx.x;
  }
  else if (index == 8) {
  	if (tx.y > cent.y)
  		tx.y = 1.0-tx.y;
 	}
 	else if (index == 9) {
  	if (tx.y  > 0.5)
  		tx = vec2(1.0-tx.x, 1.0-tx.y);
 	}
 	else if (index == 10) { // 4 way
  if (tx.x < 0.5)
  	tx.x = tx.x * 2.0;
  else
  	tx.x = 1.0 - (tx.x - 0.5) * 2.0;
  if (tx.y < 0.5)
  	tx.y = tx.y * 2.0;
  else
  	tx.y = 1.0 - (tx.y - 0.5) * 2.0;
    	//1.0 - abs(vertexcoord.yx);
  }
  else if (index == 11) { // kaleidoscope - 4 way
  	//mediump sides = 8;
  	mediump vec2 p = tx - cent;
  	mediump float r = length(p);
  	mediump float a = atan(p.y, p.x) + 1.; // + angle;
  	a = mod(a, Tau/4.);
  	a = abs(a - Tau/4./2.);
  	tx = r * vec2(cos(a), sin(a));
	}
 	else if (index == 12) { // kaleidoscope - 8 way
    	//mediump sides = 8;
		mediump vec2 p = tx - cent;
		mediump float r = length(p);
		mediump float a = atan(p.y, p.x) + 1.; // + angle;
		a = mod(a, Tau/8.);
		a = abs(a - Tau/8./2.);
		tx = r * vec2(cos(a), sin(a));
	}
  else if (index == 13) { // Julia
	  tx = gl_FragCoord.xy / resolution - 0.5;
  	const vec2 M = vec2(0.36, 0.196);
  	tx = vec2(tx.x*tx.x - tx.y*tx.y, 2.0 * tx.x * tx.y) + M;
  	tx = vec2(tx.x*tx.x - tx.y*tx.y, 2.0 * tx.x * tx.y) + M;
  	tx = vec2(tx.x*tx.x - tx.y*tx.y, 2.0 * tx.x * tx.y) + M;
  }
 	mediump vec4 rgb = texture2D(texture0, tx);

  vec3 rgb2 = vec3((rgb.r+rgb.g+rgb.b)/3.0); //clamp(vec3((rgb.r+rgb.g+rgb.b)/3.0),vec3(0.),rgb.rgb);
  rgb.xyz = vec3(mix(rgb2, rgb.xyz, min(pr,1.)));
  gl_FragColor =  vec4(rgb.xyz, 1.0);

}</script>

	<script id="shader-2-fs" type="f">
precision mediump float;
varying vec2 vTextureCoord;
uniform sampler2D texture0;
uniform vec2 resolution;
uniform vec2 mouse;
uniform int index;
uniform float time;
uniform float Param1;
uniform float Param2;
uniform float Param3;
#define PI2 6.28318530717959
const float Tau		= 6.2832;
const float speed	= .02;
const float density	= .04;
const float shape	= .04;
const float PI = 3.14159;
vec2 point = vec2(0, 0);

float chessboard(vec2 uv, vec2 nuv)
{
	bool pu = (mod(ceil(uv.x * nuv.x), 2.0) == 0.0);
	bool pv = (mod(ceil(uv.y * nuv.y), 2.0) == 0.0);

	return (pu && !pv) || (!pu && pv) ? 0.0 : 1.0;
}

vec4 texture(vec2 pos)
{
	float fval = chessboard(pos, vec2(6.0, 12.0));
	return vec4(fval, fval, fval, 1.0);
}

const float LAYERS = 4.0;
const float SPEED = 0.001;
const float DENSITY	= 0.05;
const float SATURATION	= 8.0;
const float BRIGHTNESS = 4.0;
mediump float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }

vec3 hsv2rgb(float h,float s,float v) {
	return mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;
}


float rand2( const in vec2 v )
{
	float value = fract( sin(time + v.x * 1014.43572) * 31344.234 + sin(time + v.y * 3442.43572) * 543.234);

	return value;
}

vec3 blob(vec2 p, float x, vec3 color) {
	float stime = -time * .3 * x;
	vec2 pos = vec2(cos(stime),sin(stime));
	return color * 0.15/(distance(p, pos));
}

float random( vec2 seed ) {
	return fract(sin(seed.x+seed.y*1e3)*1e5);
}

float Cell(vec2 coord) {
	vec2 cell = fract(coord) * vec2(.5,2.) - vec2(.0,.5);
	return (1.-length(cell*2.-1.))*step(random(floor(coord)),density)*2.;
}


vec3 spirala(vec2 position) {
  float d = 20.0*log(0.02 + distance(position, vec2(0.5, 0.5)) );
  //float fala = pow(sin(time - d), 2.0);
  float fala = -0.5*pow(sin(13.4*time- d*0.2)+1.0, 0.25); // falowanie
  float faza0 = atan(position.x-0.5, position.y-0.5);
  float faza = 0.0;
  float color = 1.0+sin(2.0*faza  + d + fala - time*10.0);
  color = color*color;
  return vec3(color, sin(d + 10.0*faza0)*color, cos(d + faza0)*color);
}


vec3 arc(vec4 btrir,float ang,vec2 p,vec3 color)
{
	vec2 c = resolution.yx/2.;

	float d = distance(p,vec2(c))*.7;

	float a = atan(p.x-c.x,p.y-c.y)+PI+ang;

	a = mod(a,Tau);

	if(a > btrir.x && a < btrir.y && d > btrir.z && d < btrir.w)
	{
		float diff = d-btrir.z;
		float rtrn = smoothstep(0.0,1.0,pow(sin(diff/16.*PI),0.25));

		float eb = 4.0;
		if(a < btrir.x+(PI/eb))
		{
			float ad = (btrir.x+(PI/eb))-a;
			rtrn *= 1.0-ad/(PI/eb);
		}

		if(a > btrir.y-(PI/eb))
		{
			float ad = a - (btrir.y-(PI/eb));
			rtrn *= 1.0-ad/(PI/eb);
		}
		return color*rtrn;
	}

	return vec3(0.0);
}

vec2 uv;

vec3 sinewave(float f,float a) {
  //a = 1.0;
   float fTemp = abs(1.0 / pow((sin(uv.x*f*23. + time ) * a / 50.) + uv.y, 2.0) / 760.0);
   return vec3(fTemp*0.25, fTemp*(uv.x+0.3)*0.2, fTemp*0.25*(uv.x*1.5+0.3));
}

void main(void) {

  mediump vec2 xy = 1.0-gl_FragCoord.xy / resolution;
  vec4 tx = texture2D(texture0, xy);
  vec3 tx3 = vec3(tx.x, tx.y, tx.z);
  vec3 rgb = vec3(0.);

  if (index == 0) {
		if (Param2 == 1.0)
			tx3 = 1.0-tx3;
		//tx3 *= 0.4 + float(Param3)/10.;
		vec2 pos = xy - 0.5;
		pos.x *= (resolution.x / resolution.y);

		float u = length(pos);
		float v = atan(pos.y, pos.x);

		vec3 col = clamp(vec3(-sin(v*4.0+v*2.0+time), sin(u*8.0+v-time), cos(u+v*3.0+time))*16.0, 0.0, 1.0);
		if (length(col) < .2)
			rgb = tx3;
		else
			rgb = col*tx3;
  }
  else if (index == 1)
  {
  	vec2 p1 = xy - 0.5;
  	vec2 p = p1;

  	float d = sin(length(p)+time), a = sin(mod(atan(p.y, p.x) + time + sin(d), 3.1416/3.)*3.), v = a + d, m = sin(length(p)*4.0-a+time);
  	vec3 c = vec3(-v*sin(m*sin(-d)+time*.1), v*m*sin(tan(sin(-a))*sin(-a*3.)*3.), mod(v,m));
  	if (Param2 == 1.0)
  		c.z = 1.0 - c.z;
  	c *= length(p1)*2.;
  	if (length(c) < 0.2) {
  		if (Param2 == 1.0)
  			c = 1.0-tx3;
  		else
  			c = tx3;;
  	}
  	rgb = c;
  }
  else if (index == 2) {
 		if (Param2 == 1.0)
  		tx3 = 1.0-tx3;
//   	tx3 *= 0.4 + float(Param3)*1.5;

  	vec2 away_from_center = xy - 0.5;
  	away_from_center *= away_from_center;
  	float phi01 = mod(atan(away_from_center.y, away_from_center.x * (float(Param1)+10.)/110.), 1.0);
  	float r01 = mod(0.001 / (0.001 + dot(away_from_center, away_from_center)) + time/20. + mouse.y/2., 1.0);

  	vec2 pos = vec2(phi01, r01);
  	vec4 col = texture(pos);
  	if (col.x > 0.8) {
  		if (Param2 == 1.0)
  			rgb = tx3;
  		else
  			rgb = tx3;
  	}
  	else {
  		if (Param2 == 1.0)
  			rgb = 1.0-col.rgb;
  		else
  			rgb = col.rgb;
  	}
  }
  else if (index == 3) {
    vec2 position = (100.0-float(Param3)*50.0) * (2.0 * (xy - 0.5 ));
  	float r = length(position);
  	float a = atan(position.y, position.x);

  	float d = r - a + PI2;
   	float n = PI2 * float(int(d / PI2));
  	float k = a + n;
  	float randm = sin(floor(0.07 * k * k + time));
  	if (Param2 == 1.0)
  	{
  		rgb = vec3(fract(100.0*randm))*(1.0-tx3.r);
  	}
  	else
  	{
  		rgb = fract(randm*vec3(10.0, 1000.0, 100000.0))*tx3;
  	}
  }
  else if (index == 4) {
		vec2 pos = gl_FragCoord.yx - vec2(resolution.y*.5, resolution.x*.5);
		float dist = length(pos) / resolution.y;
		mediump vec2 coord = vec2(pow(dist, 0.1), atan(pos.x, pos.y) / PI2);

		mediump vec3 color = vec3(0.0);
		float s = 20.; // - clamp(floor(float(Param1)/5.), 10., 20.);
		float b = BRIGHTNESS*SATURATION;
		if (Param2 == 1.0)
			b /= 3.;
		for (float i = 3.0; i < 5.0; ++i)	{
			float t = i*10.0 + time*i*i;
			t *= 0.5 + mouse.y/2.0;
			if (i == 4.0)
				t = -t;
			float r = coord.x - (t*SPEED);
			float c = fract(coord.y + i*.125);
			vec2  p = vec2(r, c*.5);
			vec2 uv = fract(p*s);
			float a = 1.0-length(uv*2.0-1.0);
			vec3  m = fract(r*s * vec3(-0.25, 0.5, 1.0))+i*.2;
			float d = (rand(floor(p*s))-DENSITY)*b;
			d = clamp(d*dist, 0.0, 1.0);
			color = max(color, a*m*d);
		}
		color.x = clamp(color.x-float(Param3), 0.0, 1.0);
		color.y = clamp(color.y-float(Param3), 0.0, 1.0);

		if (Param2 == 1.0)
			tx3 = 1.0-tx3;
		if (length(color) < 0.3)
			color = tx3;
		rgb =  color;
  }
  else if (index == 5)
	{
		vec3 col = vec3(1.2 - distance(xy, vec2(0.5, 0.5)) / 0.5);
		col = clamp(col, 0.0, 1.0);
		vec2 p = gl_FragCoord.xy;

		vec3 color = vec3(0.0);

		for(float i = 15.0;i < 22.0;i++)
		{
			float j = i-2.0;
			color += arc(vec4((0.0),(PI),j*16.0,(j+1.0)*16.0),time*4.0/(((fract(j*0.3)-.5)*2.0)*8.0),p, hsv2rgb(i/28.0,1.0,1.0));
		}
	    if (length(color) < 0.1)
	    {
	    	float d = distance(xy, vec2(0.5, 0.5)) * 30.;
	    	if (mod(d, 3.0) > 2.0)
	    		color = vec3(tx3.x, 0.0, tx3.z) * col;
	    	else if (mod(d, 3.0) > 1.0)
	    		color = vec3(0.0, tx3.y, tx3.z) * col;
	    	else
	    		color = vec3(tx3.x, tx3.y, 0.0) * col;
	    }
		rgb = color;
	}
	else if (index == 6)
	{
	    float sum = 0.0;
	    float size = resolution.x + resolution.y;
	    float g = 1.3;
	    int num = 20;
	    float w = resolution.x * 0.45;
	    float h = resolution.y * 0.45;
	    float t = time / 3.0;
	    for (int i = 0; i < 15; ++i) {
	        vec2 position = resolution / 2.0;
	        position.x += sin(t + float(i)) * w;
	        position.y += cos(t + (1.0 + sin(time/30.0) * 0.03) * float(i)) * h;

	        float dist = length(gl_FragCoord.xy - position);

	        sum += size / pow(dist, g);
	    }

	    vec3 color = vec3(0,0,0);
	    float val = sum / float(num);
	    if (val > 1.5)
	    {
	    	if (val < 2.0)
	    		color = vec3(0.0, val*0.3, val*0.6);
	    	else
	    		color = tx3.xyz; //vec3(0.0);
	    }
	    if (length(color) < 0.2)
	    	color = tx.xyz*clamp(vec3(1.0 - distance(xy, vec2(0.5, 0.5)) / 0.4),0.,1.);

	    rgb = color;
	}
  else if (index == 7) { // rotating wheel
  	float aspect = 1.0;//height / width;
		vec2 unipos = xy;
		vec2 bipos = unipos*2.0-1.0;
	  vec3 col = clamp(vec3(1.0 - distance(xy, vec2(0.5, 0.5)) / 0.4),0.,1.);
		bipos.x *= aspect;

		float angle = atan(bipos.x, bipos.y);

		float scale = 0.1;

		float dis = (1.0 - length(bipos)) * scale;

		float cogMin = 0.01 - 0.01 * abs(sin(-time)); // 'min' is actually the outer edge because I'm using 1/distance... for reasons I can't remember :(
		float cogMax = 0.03; // 'max' is the inner edge, so this controls the size of the hole in the middle - the higher the value the smaller the hole

		float isSolid = clamp(2.0 * (dis - cogMin) / cogMax, 0.0, 1.0);

		float hue = 0.7;
		float sat = 0.6;
		float lum = clamp(isSolid * 80.0 * (cogMax - dis), 0.0, 1.0) * length(bipos*0.25)*8.0;

		vec3 rgb2 = hsv2rgb(hue, sat, lum);
		rgb = rgb2 + col*tx.xyz;
		}
		else if (index == 8) {
  		vec2 p = (xy - vec2(0.5,0.5))  * 2.5;
  		vec3 color = vec3(0.0);

  		for(float i = 3.; i < 8.; i++)
  			color += blob(p, i, vec3(cos(i/8.), exp(-i), sin(i/8.)));
  		color /= 3.0;
  		if (length(color) < 0.5)
  			color = tx3.xyz*clamp(vec3(1.0 - distance(xy, vec2(0.5, 0.5)) / 0.4),0.,1.);

  		rgb = (clamp(vec3(1.0 - distance(xy, vec2(0.5, 0.5)) / 0.4),0.,1.)*tx3.xyz+color)/2.;
	}
	else if (index  == 9)	{ // diamond lens
		vec2 p = xy - vec2(0.5, 0.5);
		float d = (abs(p.x)+abs(p.y))*15.0;
		vec3 c;

		d += time*4.0;

		if ((abs(p.x) + abs(p.y)) > 0.5)
			c = vec3(sin(abs(d)*2.0+0.8), sin(abs(d*4.5)+0.3), sin(abs(d*3.2)+0.5));
		else
			c = tx3.xyz;
		rgb = c;

	}
	else if (index == 10)	{ // multicoloured circles into centre
		vec2 p1 = xy - vec2(0.5,0.5);
	  vec3 col = clamp(vec3(1.0 - distance(xy, vec2(0.5, 0.5)) / 0.4),0.,1.);

		vec2 p = (xy - 0.5) * abs(sin(time/10.0)) * 50.0;
		if (length(p1) > 0.3)
		{
			float d = sin(length(p)+time), a = sin(mod(atan(p.y, p.x) + time + sin(d+time), 3.1416/3.)*3.), v = a + d, m = sin(length(p)*4.0-a+time);
			vec3 c = vec3(-v*sin(m*sin(-d)+time*.1), v*m*sin(tan(sin(-a))*sin(-a*3.)*3.+time*.5), mod(v,m));
			rgb = tx3.xyz * col + c * length(p1);
		}
		else
			rgb = tx3.xyz * col;
	}
	else if (index == 11)	{ // moving cirles
		vec2 position = xy; //( gl_FragCoord.xy / resolution.xy ); //- (mouse-vec2(0.5, 0.5));
		vec3 c1 = vec3(0.0);
	  vec3 col = clamp(vec3(1.0 - distance(xy, vec2(0.5, 0.5)) / 0.4),0.,1.);

		if (length(position - 0.5) > 0.3)	{
	   		c1 = spirala(position + 0.05*vec2(sin(-4.0*time), cos(4.0*time)));
	   		rgb = c1/4.;
		}
		else
			rgb = tx3.xyz * col;
	}
  vec3 rgb2 = vec3(mix(vec3((rgb.r+rgb.g+rgb.b)/3.0), rgb.xyz, min(Param3,1.)));
  gl_FragColor = vec4(rgb2, 1.0);
}
</script>

	<script id="shader-3-fs" type="f">
precision highp float;
varying vec2 vTextureCoord;
uniform sampler2D texture0;
uniform vec2 resolution;
uniform vec2 mouse;
uniform int index;
uniform float time;
uniform float Param1;
uniform float Param2;
uniform float Param3;

float rand(vec2 co) {
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float nose(float s)
{
	return mod(sin(s * 431.), 1.);
}

float interp(float a, float b, float x)
{
	return a + (b - a) * (cos(3. * x) * -.5 + .5);
}

float pnoise(float s)
{
	float is = float(int(s));
	return interp(nose(is), nose(is + 1.), s - is);
}

const float Tau		= 6.2832;
const float speed	= .02;
const float density	= .04;
const float shape	= .04;

vec3 hsv(float h,float s,float v) {
	return mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;
}

vec2 rotate(vec2 p, float ang){
    float c = cos(ang), s = sin(ang);
    return vec2(p.y * c - p.x * s, p.y * s + p.x * c);
}

vec2 zoom(vec2 p, float factor){
    return vec2(p.x * factor, p.y * factor);
}

float rainbow(float x)
{
	x=fract(0.16666 * abs(x));
	if(x>.5) x = 1.0-x;
	if(x<.16666) return 0.0;
	if(x<.33333) return 6.0 * x-1.0;
	return 1.0;
}

void main(void) {

  vec2 xy = 1.0-gl_FragCoord.xy / resolution;
  vec4 tx = texture2D(texture0, xy);
  vec3 rgb = vec3(0.);
  float pr = max(Param3,.2);
  if (index == 0) {
  	float scale = resolution.y / 50.;
  	float radius = resolution.x;
  	vec2 pos = gl_FragCoord.xy - resolution.xy*mouse;

  	float d = length(pos)+10000.;

  	// Create the wiggle
  	d += (sin(pos.y*0.25/scale+time)*sin(pos.x*0.25/scale+time*.5))*scale*5.0;

  	d /= radius;
  	vec3 m = tan(d*0.2*sin(time+3.1415*(d*vec3(d*+.15, -d*0.33, d*.25)*0.5)));

  	rgb = tx.yxz+pr*m/4.0;
  }
	else if (index == 1) {
  	vec2 position = gl_FragCoord.xy/resolution.y-vec2((resolution.x/resolution.y)/2.0, 0.5) + 0.5 - vec2(mouse.x,mouse.y);
  	float value = sin(1.0-distance(position,vec2(sin(atan(position.y, position.x)+time),sin(time+atan(time, position.y))))*32.0+time*8.0)*0.5+0.5;
    vec3 col = vec3(value,(1.0-value)*pr,0.);
  	rgb = col+tx.yxz;
  }
  else if (index == 2) {
  	float y = (gl_FragCoord.y - resolution.y*(mouse.y)) * pow(9.0, sin(time / 2.0)) * sin((gl_FragCoord.x - resolution.x*(mouse.x)) / 2000.0) + time;
  	float value = floor(mod(y, 4.0));
  	vec3 col = vec3(sin(y)*pr, -sin(y), value*pr);
  	rgb = col+tx.yxz;
  }
  else if (index == 3) {
  	vec2 v = (gl_FragCoord.xy+resolution.x*(1.0-vec2(mouse.x, mouse.y)) - vec2(resolution.x, resolution.y)/40.0) / resolution.x * 2.0;
  	v.x-=200.0;
  	v.y-=200.0;
  	float col = 0.00;

  	for(float i = 0.0; i < 5.; i++) {
  	  	float a = i * 14.296;
  		col += cos(6.*(v.y * cos(a) + v.x * sin(a) + sin(8.0*0.004*sin(time)/20.)*100.0 ));
  	}

  	col /= 3.0;
    vec3 col3 = vec3(col*2.*pr, -col*2.*pr,-col);
  	rgb = col3+tx.yxz;
  }
  else if (index == 4) {
  	vec2 position = xy - (1.0-vec2(mouse.x, mouse.y));

  	float radius = 1.0 - length(position) * 4.0;
  	float angle = 5.0 * atan(position.y, position.x);
  	float t = time / 2.;
  	float r = sin(radius + sin(angle + sin(4.0*radius + angle + t)));
  	float g = sin(radius + t) + sin(angle + sin(5.0*radius));
  	float b = sin(sin(3.0 * radius + angle) + t * 2.0 + angle);
  	if (r < 0.01) r = 0.;
  	if (g < 0.01) g = 0.;
  	if (b < 0.01) b = 0.;
  	if (r > 0.9 && g > 0.9 && b > 0.9)
  		r = g = b = 0.0;
		vec3 col = vec3(r,g*pr,b*pr);
  	rgb = col+tx.xyz;
  }
	else if (index == 5) {
		float color = sin(time/5.) + pnoise((xy.x+mouse.x)*5.) + pnoise((xy.y+mouse.y)*5.);
		vec3 col = vec3(mod(color, .625)*pr*1.4, mod(color, .25), mod(color, .5));
		rgb = col+tx.yzx;
	}

	else if (index == 6)
	{ // hippy
	   float x = gl_FragCoord.x-mouse.x;
	   float y = gl_FragCoord.y-mouse.y;
	   float mov0 = x+y+cos(sin(time)*2.)*50.+sin(x/100.)*1000.;
	   float mov1 = y / resolution.y / 0.20 + time;
	   float mov2 = x / resolution.x / 0.2;
	   float c1 = abs(sin(mov1+time)/2.+mov2/2.-mov1-mov2+time+mouse.x);
	   float c2 = abs(sin(c1+sin(mov0/100.+time)+sin(y/10.+time)*0.2+sin((x+y)/100.)*3.)+mouse.y);
	   float c3 = abs(sin(c2+cos(mov1+mov2+c2)+cos(mov2)+sin(x/1000.)));
	   rgb = vec3( c1*pr,c2*pr,c3)*tx.xyz;
	}
	else if (index == 7)
    {
		tx.xyz = floor((tx.xyz * 2.0) + vec3(0.5)) / 2.0; // posterise image
		vec2 p = 2.0 * gl_FragCoord.xy / resolution - 1.0-mouse;

		float r = 0.75 + sin( p.x ) * ( cos( 5.0  * p.x + time ) + sin( 7.0 * p.y - time ) + sin( time ) );
		float g = 0.25 + sin( p.y ) * ( cos( 3.0  * p.y + time ) + sin( 9.0 * p.x - time ) - cos( time ) );
		float b = 0.75 + sin( p.x ) * ( cos( 11.0 * p.x + time ) + sin( 3.0 * p.y + time ) + cos( time ) );

		vec3 color = vec3( r, g*pr, b*pr)/2.;
		rgb = tx.xyz*.1+color;
    }

	else if (index == 8)
	{ // hippy
		tx.xyz = floor((tx.xyz * 3.0) + vec3(0.5)) / 3.0; // posterise image
		xy -= (1.0-mouse);
		float value = sin(1.0-distance(xy,vec2(sin(atan(xy.y, xy.x)+time/3.0),sin(time/2.0+atan(time, xy.y)-length(xy))))*22.0+time*4.0)*.3+.3;
		//gl_FragColor = vec4(value-tx3.x, value-tx3.y, (1.0-value)-tx3.z,1.0 );
		rgb = hsv(value*pr+xy.x*xy.y, 1.0, 1.0)+tx.zxy/2.0; // both work with different colours
	}
	else if (index == 9)
	{ // hippy with box blur
    float x = 1.0/resolution.x;
  	float y = 1.0/resolution.y;
		vec2 firstOffset = vec2(1.5 * x, 1.5 * y);
  	vec2 secondOffset = vec2(3.5 * x, 3.5 * y);
		xy -= (1.0-mouse);

		tx *= 0.2;
    tx += texture2D(texture0, xy + firstOffset) * 0.2;
    tx += texture2D(texture0, xy - firstOffset) * 0.2;
    tx += texture2D(texture0, xy + secondOffset) * 0.2;
    tx += texture2D(texture0, xy - secondOffset) * 0.2;

		//tx3 = floor((tx3 * 3.0) + vec3(0.5)) / 3.0; // posterise image
		float value = sin(1.0-distance(xy,vec2(sin(atan(xy.y, xy.x)+time/2.0),sin(time/2.0+atan(time, xy.y)-length(xy))))*32.0+time*8.0)*.3+.3;

		rgb = clamp(hsv(value*pr+xy.x*xy.y, 1.0, 1.0)*(1.0-tx.xyz), 0.0, 1.0);
	}
	else if (index == 10)
	{ // hippy
		tx.xyz = floor((tx.xyz * 2.0) + vec3(0.5)) / 2.0; // posterise image
		vec2 pos = -0.5 + ( xy ) * 5.1+ mouse;// *mouse.x;
		float v = sin(pos.x+pos.y)+cos(pos.y*(1.0+pos.x)+sin(time/7.0))+ pos.x+pos.y + time/3.99999999;
		float a = mod((v), 0.2);
		rgb = vec3(sin(a-pos.y-cos(time)), cos(a+pos.x*pos.y+time), sin(a+pos.x))*pr+tx.zxy;
	}
	else if (index > 10)
	{ // Moving Vertical and/or bars
		tx.xyz = floor((tx.xyz * 5.0) + vec3(0.5)) / 5.0; // posterise image
		vec2 p = xy.yx + mouse.yx;
		p += time * 0.01;

		vec3 color;
		if (index == 11)
		  color = vec3(sin(p.x * 11.0), sin(sin(p.x + time * 0.03) * 101.0), sin(p.x*53.0));
    else if (index == 12)
		  color = vec3(sin(p.y * 11.0), sin(sin(p.y + time * 0.03) * 101.0), sin(p.y*53.0));
    else
		  color = vec3(sin(p.y * 11.0), sin(sin(p.x + time * 0.03) * 101.0), sin(p.y*53.0));
		rgb = clamp(color - (0.2*(sin(time)+1.0)*vec3(1.0, 1.0, 1.0)*pr),0.,1.) + tx.yxz;
	}
	gl_FragColor = vec4(rgb,1.);
}
</script>

	<script id="shader-4-fs" type="f">
    precision mediump float;
    varying vec2 vTextureCoord;
    uniform sampler2D texture0;
    uniform vec2 resolution;
    uniform vec2 mouse;
    uniform int index;
    uniform float time;
    uniform float Param1;
    uniform float Param2;
    uniform float Param3;
vec3 rgb2hsv(vec3 c)
{
  vec4 K = vec4(0., -1. / 3., 2. / 3., -1.);
  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

  float d = q.x - min(q.w, q.y);
  float e = 1.0e-10;
  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c)
{
  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
  return c.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), c.y);
}

void main(void) {

  vec2 xy = 1.0-gl_FragCoord.xy / resolution;
  vec4 tx = texture2D(texture0, xy);
	if (index < 7)
	{
  	float levels=32.;

  	//float x = (tx.r + tx.g + tx.b) / 3.0;//use this for BW effect.
  	vec4 x=tx;
  	x = mod(x - time*.05, 1.);
  	x = floor(x*levels);
  	x = mod(x,1.5);
    x.x *= Param3;
    if (index == 0)
    	gl_FragColor= x;
    else if (index == 1)
  	  gl_FragColor= vec4(x.r, 0.,x.b,1.);
    else if (index == 2)
  	  gl_FragColor= vec4(x.r, x.g, 0., 1.0);
    else if (index == 3)
  	  gl_FragColor= vec4(0., x.xy, 1.0);
    else if (index == 4)
  	  gl_FragColor= vec4(x.xxx, 1.0);
    else if (index == 5)
  	  gl_FragColor= vec4(x.yxz, 1.0);
    else if (index == 6)
  	  gl_FragColor= vec4(x.zxx, 1.0);
	}
	else {
  	vec3 color = vec3(0.0, 0.0, 0.0);
  	color = rgb2hsv(color);
  	color.x = mod(((tx.x + tx.y + tx.z) * 0.7) + (time*0.25), 1.0);
  	color.y = 1.0;
  	color.z = 1.0;
  	color = hsv2rgb(color);

  	color = mix(color.xyz, tx.xyz,Param3);
  	color.xyz = floor((color.xyz * 8.0) + vec3(0.5)) / 8.0;
    if (index == 7)
    	gl_FragColor= vec4(color, 1.0);
    else if (index == 8)
    	gl_FragColor= vec4(color.xxy, 1.0);
    else if (index == 9)
    	gl_FragColor= vec4(color.xyx, 1.0);
    else if (index == 10)
    	gl_FragColor= vec4(color.yxx, 1.0);
    else if (index == 11)
    	gl_FragColor= vec4(color.xxx, 1.0);
    else if (index == 12)
    	gl_FragColor= vec4(0., color.yz, 1.0);
    else if (index == 13)
    	gl_FragColor= vec4(color.xy, 0., 1.0);
    else if (index == 14)
    	gl_FragColor= vec4(color.x, 0., color.z, 1.0);
	}

}
</script>

	<script id="shader-5-fs" type="f">
precision mediump float;
varying vec2 vTextureCoord;
uniform sampler2D texture0;
uniform vec2 resolution;
uniform vec2 mouse;
uniform int index;
uniform float time;
uniform float Param1;
uniform float Param2;
uniform float Param3;

float round(float v) {
	if(v - floor(v) >= 0.5) return floor(v)+1.0;
	else return floor(v);
}

vec2 round(vec2 v) {
	vec2 ret = vec2(0.0);
	if(v.x - floor(v.x) >= 0.5) ret.x = floor(v.x)+1.0;
	else ret.x = floor(v.x);
	if(v.y - floor(v.y) >= 0.5) ret.y = floor(v.y)+1.0;
	else ret.y = floor(v.y);
	return ret;
}

float triwave(float x) {
	return 1.0-4.0*abs(0.5-fract(0.5*x + 0.25));
}

float rand(vec2 co) {
	float t = round(time*4.0);
    return fract(sin(dot(co.xy ,vec2(1.9898,7.233))) * t*t);
}

float pixelsize = 16.0;
float PIXEL_FACTOR = 3.0;
float smooth(float f) {
	return 32.0*f*f*(0.25*f*f-0.5*f+0.25)+0.5;
}

float s;
void srand(vec2 p){
	s=sin(dot(p,vec2(423.62431,321.54323)));
}
float rand(){
	s=fract(s*32322.65432+0.12333);
	return abs(fract(s));
}
float grad(float t){
	return 6.0*pow(t,5.0)-15.0*pow(t,4.0)+10.0*pow(t,3.0);
}
mat2 rot2d(float a){
	float c=cos(a);
	float s=sin(a);
	return mat2(
		c,-s,
		s, c);
}

vec4 voronoi2d(vec2 p,float t, float RES){
	float v=8.0;
	vec4 c;
	vec2 f=floor(p);
	for(float i=-3.0;i<3.0;i++)
	for(float j=-3.0;j<3.0;j++){
		srand(f+vec2(i,j));
		vec2 o;
		o.x=rand();
		o.y=rand();
		o*=rot2d(t*(rand()-0.1));
		float d=distance(p,f+vec2(i,j)+o);
		if(d<v){
			v=d;
			c=texture2D(texture0,1.0-(f+vec2(i,j)+o)/RES);
		}
	}
	return c;
}

#define RAIN_SPEED 1.75 // Speed of rain droplets
float DROP_SIZE = 2.0;  // Higher value lowers, the size of individual droplets

float rand2(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float rchar(vec2 outer, vec2 inner, float t) {
	//return float(rand(floor(inner * 2.0) + outer) > 0.9);

	vec2 seed = floor(inner * 4.0) + outer.y;
	if (rand2(vec2(outer.y, 23.0)) > 0.98) {
		seed += floor((t + rand(vec2(outer.y, 49.0))) * 3.0);
	}

	return float(rand2(seed) > 0.5);
}

void main(void) {
  mediump vec2 cent = vec2(0.5, 0.5);
	mediump vec2 xy = 1.0-gl_FragCoord.xy / resolution;
 	mediump vec3 rgb = texture2D(texture0, xy).xyz;
	if (index < 5) {
	  if (index == 1 || index == 3)
	    pixelsize = 32.;
	  else if (index > 1)
	    pixelsize = 64.;

  	vec2 position = ( gl_FragCoord.xy);
  	vec3 color = vec3(0.0);
  	vec2 rposition = round(((position-(pixelsize/2.0))/pixelsize));
  	color = vec3(rand(rposition),rand(rposition-12.0),rand(rposition+46.0));

  	//color *= vec3(abs(sin((position.x+2.0))) * abs(sin((position.y+2.0))));

  	color *= vec3(clamp( abs(triwave(position.x/pixelsize))*2.0 , 0.0 , 1.0 ));
  	color *= vec3(clamp( abs(triwave(position.y/pixelsize))*2.0 , 0.0 , 1.0 ));

    if (index < 3)
      gl_FragColor = vec4( color*rgb, 1.0 );
    else {
    	if (color.r+color.g+color.b < 0.2)
      	gl_FragColor = vec4( rgb, 1. );
      else
    	  gl_FragColor = vec4(1.5*rgb-color, 1.0 );
    }

  }
  else if (index < 8) { // stretch distortion filter
    float SUBPIXEL_SIZE = 2.;
    if (index == 6)
      SUBPIXEL_SIZE = 4.;
    else if (index == 7)
      SUBPIXEL_SIZE = 8.;
    vec2 p = gl_FragCoord.xy / SUBPIXEL_SIZE;
    vec2 uv = floor(p)*SUBPIXEL_SIZE / resolution.xy;

    vec4 result = vec4(0.);

    vec2 remainder = floor(mod(p, 2.0)+0.1);

    rgb*=1.2;

    if (remainder.x == 1.) {
    	if (remainder.y == 1.) {
            result.g = rgb.g/sqrt(2.);
        } else {
            result.r = rgb.r;
        }
    } else {
        if (remainder.y == 1.) {
            result.b = rgb.b;
        } else {
            result.g = rgb.g/sqrt(2.);
        }
    }

  	gl_FragColor = result;
	}
	else if (index < 11)
	{
	  if (index == 9)
	    PIXEL_FACTOR=6.;
	  else if (index == 10)
	    PIXEL_FACTOR=12.;
	  vec2 chunkCoord = floor(gl_FragCoord.xy / PIXEL_FACTOR) * PIXEL_FACTOR;
    vec2 locCoord = (gl_FragCoord.xy - chunkCoord) / PIXEL_FACTOR;
    vec4 color = vec4(floor(5.0 * texture2D(texture0,1.0- chunkCoord / resolution.xy).xyz) / 5.0, 1.0);
    float grey = (color.x + color.y + color.z) / 3.0;
    gl_FragColor = color * smooth(locCoord.x) * smooth(locCoord.y);
	}
  else if (index < 14)
  {
    float RES = 50.;
    if (index == 12)
      RES = 100.;
    else if (index == 11)
      RES = 150.;
  	float r=resolution.x/resolution.y;
  	vec2 s=gl_FragCoord.xy/vec2(resolution.x,resolution.y);
  	gl_FragColor=voronoi2d(s*RES,time,RES);
  }
  else { // matrix
  	vec2 position = gl_FragCoord.xy / resolution.xy;
  	vec2 uv = position;
    position.x /= resolution.x / resolution.y;
  	float globalTime = time * RAIN_SPEED;
  	if (index == 15)
  	  DROP_SIZE = 4.;
  	else if (index == 16)
  	  DROP_SIZE = 1.;
  	float scaledown = DROP_SIZE;
  	float rx = gl_FragCoord.x / (41.0 * scaledown);
  	float mx = 41.0*scaledown*fract(position.x * 33.0 * scaledown);
  	vec4 result;

  	if (mx > 12.0 * scaledown) {
  		result = vec4(0.0);
  	} else 	{
      float x = floor(rx);
  		float r1x = floor(gl_FragCoord.x / (15.0));

  		float ry = position.y*600.0 + rand2(vec2(x, x * 3.0)) * 100000.0 + globalTime* rand2(vec2(r1x, 23.0)) * 120.0;
  		float my = mod(ry, 15.0);
  		if (my > 12.0 * scaledown) {
  			result = vec4(0.0);
  		} else {

  			float y = floor(ry / 15.0);

  			float b = rchar(vec2(rx, floor((ry) / 15.0)), vec2(mx, my) / 12.0, globalTime);
  			float col = max(mod(-y, 24.0) - 4.0, 0.0) / 20.0;
  			vec3 c = col < 0.8 ? vec3(0.0, col / 0.8, 0.0) : mix(vec3(0.0, 1.0, 0.0), vec3(1.0), (col - 0.8) / 0.2);

  			result = vec4(c * b, 1.0)  ;
  		}
  	}

  	position.x += 0.05;

  	scaledown = DROP_SIZE;
  	rx = gl_FragCoord.x / (29.0 * scaledown);
  	mx = 39.0*scaledown*fract(position.x * 31.0 * scaledown);

  	if (mx > 12.0 * scaledown) {
  		result += vec4(0.0);
  	} else {
      float x = floor(rx);
  		float r1x = floor(gl_FragCoord.x / (12.0));

  		float ry = position.y*700.0 + rand2(vec2(x, x * 3.0)) * 100000.0 + globalTime* rand2(vec2(r1x, 23.0)) * 120.0;
  		float my = mod(ry, 15.0);
  		if (my > 12.0 * scaledown) {
  			result += vec4(0.0);
  		} else {
  			float y = floor(ry / 15.0);

  			float b = rchar(vec2(rx, floor((ry) / 15.0)), vec2(mx, my) / 12.0, globalTime);
  			float col = max(mod(-y, 24.0) - 4.0, 0.0) / 20.0;
  			vec3 c = col < 0.8 ? vec3(0.0, col / 0.8, 0.0) : mix(vec3(0.0, 1.0, 0.0), vec3(1.0), (col - 0.8) / 0.2);

  			result += vec4(c * b, 1.0)  ;
  		}
  	}

  	if (index >= 17)
  	  result = result * length(rgb.rgb) + 0.52 * vec4(rgb.rrr,1.);
  	else
  	  result = result * length(rgb.rgb) + 0.52 * vec4(0.,rgb.gb,1.);
  	if(result.b < 0.5)
  	result.b = result.g * 0.5 ;
  	if (index == 18)
  	  result = result.bgra;
  	else if (index == 19)
  	  result=result.brga;
  	else if (index == 20)
  	  result=result.grga;
  	gl_FragColor = result;
  }

}
</script>

	<script id="shader-6-fs" type="f">
precision highp float;
varying vec2 vTextureCoord;
uniform sampler2D texture0;
uniform vec2 resolution;
uniform vec2 mouse;
uniform int index;
uniform float time;
uniform float Param1;
uniform float Param2;
uniform float Param3;

const int intensity_level = 16;
float bw(vec2 coords) {
	vec4 lm = texture2D(texture0, coords/4.28) * vec4(0.21, 0.71, 0.07, 1);
	return lm.r+lm.g+lm.b;
}

void main(void) {
  vec3 colors[4];
  colors[0] = vec3(0.0, 0.0, 1.0);
  colors[1] = vec3(1.0, 1.0, 0.0);
  colors[2] = vec3(1.0, 0.0, 0.0);
  colors[3] = vec3(1.0, 0.0, 1.0);

  mediump vec2 cent = vec2(0.5,0.5);
  vec2 tx = 1.0-gl_FragCoord.xy / resolution;
  vec4 rgb = texture2D(texture0, tx);

  if (index <= 2) { // golden
  	vec2 step = 1.0 / resolution;

		vec3 texA = texture2D( texture0, tx + vec2(-step.x, -step.y) * 1.5 ).rgb;
		vec3 texB = texture2D( texture0, tx + vec2( step.x, -step.y) * 1.5 ).rgb;
		vec3 texC = texture2D( texture0, tx + vec2(-step.x,  step.y) * 1.5 ).rgb;
		vec3 texD = texture2D( texture0, tx + vec2( step.x,  step.y) * 1.5 ).rgb;

		float shadeA = dot(texA, vec3(0.333333));
		float shadeB = dot(texB, vec3(0.333333));
		float shadeC = dot(texC, vec3(0.333333));
		float shadeD = dot(texD, vec3(0.333333));

		float shade = 15.0 * pow(max(abs(shadeA - shadeD), abs(shadeB - shadeC)), 0.5);

		vec3 col = mix(vec3(0.1, 0.18, 0.3), vec3(0.4, 0.3, 0.2), shade);

		if (index >= 1)
			col = 1.0-floor((col * 3.0) + vec3(0.5)) / 3.0;
		if (index >= 2)
		{
		    const mediump vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);
     		mediump float luminance = dot(rgb.xyz, luminanceWeighting);
     		if (index == 2)
     			col = (col + mix(colors[2], colors[1], luminance))/2.;
     		else
     			col = (col +mix(colors[2], colors[0], luminance))/2.;
		}
    gl_FragColor = vec4(col,1.0);
    return;
  }
  else if (index <= 5) { // emboss filter
		float spinT = time*0.2;
		vec2 cutDir = vec2(cos(spinT), sin(spinT));
		if( dot(cutDir, tx-vec2(cent.x,cent.y)) < 0.0 && index < 4)	{
			gl_FragColor = rgb;
			return;
		}

    vec2 onePixel = vec2(1.0 / resolution.x, 1.0 / resolution.y);

    vec2 texCoord = tx;
    texCoord.x +=  (onePixel.x * 6.0);
    texCoord.y +=  (onePixel.y * 6.0);


    vec4 color;
    color.rgb = vec3(0.5);
    color -= texture2D(texture0, (texCoord - onePixel)) * 5.0;
    color += texture2D(texture0, (texCoord + onePixel)) * 5.0;

    color.rgb = vec3((color.r + color.g + color.b) / 3.0);
    if (index == 4)
    	color *= rgb;
    if (index == 5)
	    color = (2.0*color + (1.0-rgb))/3.;
    gl_FragColor = vec4(color.rgb, 1.0);
    return;
  }
  else if (index < 10) { // sketch filter
    const mediump vec3 W = vec3(0.2125, 0.7154, 0.0721);
    mediump vec3 textureColor = rgb.xyz;

    mediump vec2 stp0 = vec2(1.0 / resolution.x, 0.0);
    mediump vec2 st0p = vec2(0.0, 1.0 / resolution.y);
    mediump vec2 stpp = vec2(1.0 / resolution.x, 1.0 / resolution.y);
    mediump vec2 stpm = vec2(1.0 / resolution.x, -1.0 / resolution.y);

    mediump float i00   = dot( textureColor, W);
    mediump float im1m1 = dot( texture2D(texture0, tx - stpp).rgb, W);
    mediump float ip1p1 = dot( texture2D(texture0, tx + stpp).rgb, W);
    mediump float im1p1 = dot( texture2D(texture0, tx - stpm).rgb, W);
    mediump float ip1m1 = dot( texture2D(texture0, tx + stpm).rgb, W);
    mediump float im10 = dot( texture2D(texture0, tx - stp0).rgb, W);
    mediump float ip10 = dot( texture2D(texture0, tx + stp0).rgb, W);
    mediump float i0m1 = dot( texture2D(texture0, tx - st0p).rgb, W);
    mediump float i0p1 = dot( texture2D(texture0, tx + st0p).rgb, W);
    mediump float h =-im1p1 - 2.0 * i0p1 - ip1p1 + im1m1 + 2.0 * i0m1 + ip1m1;
    mediump float v =-im1m1 - 2.0 * im10 - im1p1 + ip1m1 + 2.0 * ip10 + ip1p1;

    mediump float mag = 1.0 - length(vec2(h, v));
    mediump vec3 target = vec3(mag);

    if (index == 6)
    	    gl_FragColor = vec4(vec3(1.0)-mix(textureColor, target, 0.8).xyz, 1.0);
    else if (index == 7)
    	    gl_FragColor = vec4(textureColor*.7 + vec3(1.0)-mix(textureColor, target, 0.8).xyz, 1.0);
    else if (index == 8)
    	    gl_FragColor = vec4(mix(textureColor, target, 0.6).yxz, 1.0);
    else if (index == 9)
    	    gl_FragColor = vec4(mix(textureColor, target, 0.6).xyz, 1.0);
    return;
  }
  else if (index >= 10) { // edge
    int intensity_count[intensity_level];
    // cleanup
    for (int i = 0; i < intensity_level; ++i) {
        intensity_count[i] = 0;
    }

    // step 1
    // for each pixel within radius of a pixel
    for (float x = -1.0; x < 1.0; ++x) {
      for (float y = -1.0; y < 1.0; ++y) {
        vec2 abs_pos = vec2(x, y);
        if (1.0 < dot(abs_pos, abs_pos))
          continue;
        vec2 pos = (abs_pos / resolution) + tx;
        vec4 col_element = texture2D(texture0, pos);
        int current_intensity = int(
          (dot(col_element, vec4(1.0, 1.0, 1.0, 0.0)) / 3.0) *
          float(intensity_level)
        );
        current_intensity = (current_intensity >= intensity_level) ?
          intensity_level - 1 :
        	current_intensity;
        for (int i = 0; i < intensity_level; ++i) {
          if (i == current_intensity) {
            intensity_count[i] += 1;
            break;
          }
        }
      }
    }
    // step 2
    // find the maximum intensity
    int max_level = 0;
   	float val = 0.0;
    vec4 col_out = vec4(0.0, 0.0, 0.0, 1.0);
    for (int level = 0; level < intensity_level; ++level) {
      if (intensity_count[level] > max_level) {
        max_level = intensity_count[level];
        val = float(max_level) / 4.0;
        col_out = vec4(val, val, val, 1.0);
      }
    }
   	// step 3
      // write the final color
    if (index == 10)
     	rgb = texture2D(texture0, tx)/2.0 + (1.0-col_out);
    else
     	rgb = col_out;
  }

  gl_FragColor = vec4(rgb.xyz, 1.0);
  return;
}
</script>

	<script id="shader-7-fs" type="f">
precision mediump float;
varying vec2 vTextureCoord;
uniform sampler2D texture0;
uniform vec2 resolution;
uniform vec2 mouse;
uniform int index;
uniform float time;
uniform float Param1;
uniform float Param2;
uniform float Param3;
const mediump vec2 sampleDivisor = vec2(0.02, 0.02);
#define PI 3.14159265359
#define VerticalBeamDistance 170.
#define BeamWidth 20.

float bars() {
	float CurrentBeamIndex = floor((gl_FragCoord.x + (VerticalBeamDistance / 2.)) / VerticalBeamDistance);
	float CurrentVerticalBeamX = CurrentBeamIndex * VerticalBeamDistance;
	float dist = distance(CurrentVerticalBeamX, gl_FragCoord.x);
	float intensity = clamp((BeamWidth - dist) / BeamWidth, 0.,1.);

	CurrentBeamIndex = floor(gl_FragCoord.x / VerticalBeamDistance)+1.;
	float effectiveY = 470.;//sqrt(mod(pow(functionX,2.),40.))*50.+70.;
	if (CurrentBeamIndex == 1.)
		effectiveY = Param1*6.;
	else if (CurrentBeamIndex == 2.)
		effectiveY = Param2*6.;
	else
		effectiveY = Param3*30.;
	dist = distance(effectiveY, gl_FragCoord.y);
	intensity = max(intensity, clamp((BeamWidth - dist) / BeamWidth, 0.,1.));

	return intensity ;
}

void main(void) {
  mediump vec2 cent = vec2(0.5, 0.5);

	mediump vec2 tx = 1.0-gl_FragCoord.xy / resolution;
	int makeBlack = 0;

	lowp float checkForPresenceWithinDot = 1.0;
	if (index == 0) { // holes in the screen pixelated - 1
     mediump float fractionalWidthOfPixel = 0.02;
	 	 mediump float aspectRatio = 0.8;
     mediump float dotScaling = 0.9;
     mediump vec2 sampleDivisor = vec2(fractionalWidthOfPixel, fractionalWidthOfPixel / aspectRatio);

     mediump vec2 samplePos = tx - mod(tx, sampleDivisor) + 0.5 * sampleDivisor;
     mediump vec2 textureCoordinateToUse = vec2(tx.x, (tx.y * aspectRatio + 0.5 - 0.5 * aspectRatio));
     mediump vec2 adjustedSamplePos = vec2(samplePos.x, (samplePos.y * aspectRatio + 0.5 - 0.5 * aspectRatio));
     mediump float distanceFromSamplePoint = distance(adjustedSamplePos, textureCoordinateToUse);
     //checkForPresenceWithinDot = step(distanceFromSamplePoint, (fractionalWidthOfPixel * 0.5) * dotScaling);
     if (step(distanceFromSamplePoint, (fractionalWidthOfPixel * 0.5) * dotScaling) >= 1.0) {
	     	tx = samplePos;
     }
     else {
     	makeBlack = 1;
     }

	}

	else if (index == 1) { // holes in the screen pixelated - 2
   mediump float fractionalWidthOfPixel = 0.02;
 	 mediump float aspectRatio = 0.8;
   mediump float dotScaling = 0.9;
   mediump vec2 sampleDivisor = vec2(fractionalWidthOfPixel, fractionalWidthOfPixel / aspectRatio);

   mediump vec2 samplePos = tx - mod(tx, sampleDivisor) + 0.5 * sampleDivisor;
   mediump vec2 textureCoordinateToUse = vec2(tx.x, (tx.y * aspectRatio + 0.5 - 0.5 * aspectRatio));
   mediump vec2 adjustedSamplePos = vec2(samplePos.x, (samplePos.y * aspectRatio + 0.5 - 0.5 * aspectRatio));
   mediump float distanceFromSamplePoint = distance(adjustedSamplePos, textureCoordinateToUse);
   //checkForPresenceWithinDot = step(distanceFromSamplePoint, (fractionalWidthOfPixel * 0.5) * dotScaling);
   if (step(distanceFromSamplePoint, (fractionalWidthOfPixel * 0.5) * dotScaling) >= 1.0) { // don't black it out
   	// checkForPresenceWithinDot = 1.0;
   }
   else
   	tx = samplePos;
  }
  else if (index == 2) { // stripes in the screen
   mediump float fractionalWidthOfPixel = 0.1;
   mediump float dotScaling = 0.6;
   mediump float sampleDivisor = fractionalWidthOfPixel;

   mediump float samplePos = tx.x - mod(tx.x, sampleDivisor) + 0.5 * sampleDivisor;
   mediump float distanceFromSamplePoint = distance(samplePos, tx.x);
   checkForPresenceWithinDot = step(distanceFromSamplePoint, (fractionalWidthOfPixel * 0.5) * dotScaling);
  }
  else if (index == 3) { // stripes in the screen 2
   mediump float fractionalWidthOfPixel = 0.2;
   mediump float dotScaling = 0.5;
   mediump float sampleDivisor = fractionalWidthOfPixel;

   mediump float samplePos = tx.x - mod(tx.x, sampleDivisor) + 0.5 * sampleDivisor;
   mediump float distanceFromSamplePoint = distance(samplePos, tx.x);
   checkForPresenceWithinDot = step(distanceFromSamplePoint, (fractionalWidthOfPixel * 0.5) * dotScaling);
  }
  else if (index == 4) { // holes in the screen
   mediump float fractionalWidthOfPixel = 0.05;
 	 mediump float aspectRatio = 0.8;
   mediump float dotScaling = 0.9;
   mediump vec2 sampleDivisor = vec2(fractionalWidthOfPixel, fractionalWidthOfPixel / aspectRatio);

   mediump vec2 samplePos = tx - mod(tx, sampleDivisor) + 0.5 * sampleDivisor;
   mediump vec2 textureCoordinateToUse = vec2(tx.x, (tx.y * aspectRatio + 0.5 - 0.5 * aspectRatio));
   mediump vec2 adjustedSamplePos = vec2(samplePos.x, (samplePos.y * aspectRatio + 0.5 - 0.5 * aspectRatio));
   mediump float distanceFromSamplePoint = distance(adjustedSamplePos, textureCoordinateToUse);
   checkForPresenceWithinDot = step(distanceFromSamplePoint, (fractionalWidthOfPixel * 0.5) * dotScaling);
  }
  else if (index == 5) // pixelate
      tx = tx - mod(tx, sampleDivisor/2.0);
  else if (index == 6) // pixelate
      tx = tx - mod(tx, sampleDivisor);
  else if (index == 7) { // polar pixelation 2
	 mediump vec2 normCoord = 2.0 * tx - 1.0;
	 mediump vec2 normCenter = 2.0 * cent - 1.0;
	 mediump vec2 pixelSize = vec2(0.03, 0.03);

	 normCoord -= normCenter;

	 mediump float r = length(normCoord); // to polar coords
	 mediump float phi = atan(normCoord.y, normCoord.x); // to polar coords

	 r = r - mod(r, pixelSize.x) + 0.03;
	 phi = phi - mod(phi, pixelSize.y);

	 normCoord.x = r * cos(phi);
	 normCoord.y = r * sin(phi);

	 normCoord += normCenter;

	 tx = normCoord / 2.0 + 0.5;
  }
  else if (index == 8) { // polar pixelation
   mediump vec2 normCoord = 2.0 * tx - 1.0;
   mediump vec2 normCenter = 2.0 * cent - 1.0;
   mediump vec2 pixelSize = vec2(0.05, 0.05);

   normCoord -= normCenter;

   mediump float r = length(normCoord); // to polar coords
   mediump float phi = atan(normCoord.y, normCoord.x); // to polar coords

   r = r - mod(r, pixelSize.x) + 0.03;
   phi = phi - mod(phi, pixelSize.y);

   normCoord.x = r * cos(phi);
   normCoord.y = r * sin(phi);

   normCoord += normCenter;

   tx = normCoord / 2.0 + 0.5;
  }
  else if (index > 8) { //
  	vec3 txt = texture2D(texture0,tx).rgb;
  	vec3 col = txt/length(txt); // chrominance
  	float t = time/4.0;
  	float lum = (txt.r+txt.g+txt.b)/3., rg = atan(txt.r,txt.g);
  	if (index <= 10) {
  		lum = floor(10.*lum)/10.;
		  float diag1 = sin(2.*PI*(gl_FragCoord.x+gl_FragCoord.y)*lum/2.);
		  float diag2 = sin(2.*PI*(gl_FragCoord.x-gl_FragCoord.y)*lum/2.0);
		  if (index == 9)
		    col = (txt.g>txt.r) ? vec3(diag1) : vec3(diag2);
		  else
    	  col = (txt.g>txt.r) ? vec3(0.,diag1,0.) : vec3(diag2,0.,0.);
  	}
  	else if (index == 11) {
  		float a = 2.*rg;  	a = floor(10.*a/PI)*PI/10.;
  		float b = lum*PI;  	b = floor(10.*b/PI)*PI/10.;
  		vec2 dirA = vec2(cos(a),sin(a));
  		vec2 dirB = vec2(cos(b),sin(b));
  		a = 2.*PI*dot(dirA,gl_FragCoord.xy); a = .5-.5*cos(a);
  		b = 2.*PI*dot(dirB,gl_FragCoord.xy); b = .5-.5*cos(b);
  		col = vec3(a-b);
  	}
  	else {
  		float a,b;
  		if (index==12) {
  			a = 2.*rg;  	a = floor(10.*a/PI)*PI/10. +PI/2.;
  			b = lum;		b = floor(10.*b)/10.;
  		} else {
  			a = lum*PI;  	a = floor(10.*a/PI)*PI/10.;// +PI/2.;
  			b = 1.-rg;		b = floor(10.*b)/10.;
  		}
  		vec2 dir = vec2(cos(a),sin(a));
  		a = 2.*PI*dot(dir,gl_FragCoord.xy);
  		col = vec3(.5-.5*cos(.5*b*a))*vec3(txt/length(txt));
  	}
   	float i = bars();
  	if (i > 0.1)
    	col = vec3(.9,.9,.9) * i;
		gl_FragColor = vec4(col,1.0);
		return;
  }

	mediump vec4 rgb = texture2D(texture0, tx);
  if (checkForPresenceWithinDot < 1.) // do screen full of holes
   	rgb = vec4(.0);

   	float i = bars();
  	if (i > 0.1)
    	rgb.xyz = vec3(.9,.9,.9) * i;

	gl_FragColor =  vec4(rgb.xyz, 1.);

}
</script>

	<script id="shader-8-fs" type="f">
precision mediump float;
varying vec2 vTextureCoord;
uniform sampler2D texture0;
uniform vec2 resolution;
uniform vec2 mouse;
uniform int index;
uniform float time;
uniform float Param1;
uniform float Param2;
uniform float Param3;
const float Tau	= 6.2832;

float snoise(vec3 uv, float res)
{
	const vec3 s = vec3(1e0, 1e2, 1e4);

	uv *= res;

	vec3 uv0 = floor(mod(uv, res))*s;
	vec3 uv1 = floor(mod(uv+vec3(1.), res))*s;

	vec3 f = fract(uv);
	f = f*f*(3.0-2.0*f);

	vec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,
		      uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);

	vec4 r = fract(sin(v*1e-3)*1e5);
	float r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);

	r = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);
	float r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);

	return mix(r0, r1, f.z)*2.-1.;
}


vec2 noise(vec2 n)
{
	vec2 ret;
	ret.x=fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453)*2.0-1.0;
	ret.y=fract(sin(dot(n.xy, vec2(34.9865, 65.946)))* 28618.3756)*2.0-1.0;
	return normalize(ret);
}

float perlin(vec2 p)
{
	vec2 q=floor(p);
	vec2 r=fract(p);
	float rt;
	float s=dot(noise(q),p-q);
	float t=dot(noise(vec2(q.x+1.0,q.y)),p-vec2(q.x+1.0,q.y));
	float u=dot(noise(vec2(q.x,q.y+1.0)),p-vec2(q.x,q.y+1.0));
	float v=dot(noise(vec2(q.x+1.0,q.y+1.0)),p-vec2(q.x+1.0,q.y+1.0));
	rt = r.x*r.x;
	float Sx=3.0*rt-2.0*(rt*r.x);
	float a=s+Sx*(t-s);
	float b=u+Sx*(v-u);
	rt = r.y*r.y;
	float Sy=3.0*rt-2.0*(rt*r.y);
	return  a+Sy*(b-a);
}

float fbm(vec2 p)
{
	float f=0.0;
	float tme=-time;
	f+=perlin(p-time);
	f+=perlin(p*4.0+time)*0.25;
	return f;
}

const float NUM_BUBBLES = 20.0;
lowp vec4 doBubble(vec2 coord,  float bubble)
{
	mediump float mtime = time * 500.0 + bubble * 1000.0;
	lowp vec4 result = vec4(0.0,0.0,0.0,1.0);
	lowp vec3 position = vec3(cos( mtime / (500.0 + bubble * 5.0) ) * 0.2 + mod( bubble / 10.0, 1.0 ) / 10.0 - sin( bubble * 370.0 )*resolution.x/resolution.y,- mod( ( mtime /  2000.0 * (cos(bubble*3.0)+2.0) ), 3.0 + bubble / 100.0) + 1.0, 0);
	lowp float radius = 0.05 * ( cos( bubble * 3.0) + 1.0 ) + 0.05;
	lowp vec3 color = vec3( -0.1, -0.1, -0.1 );
	mediump float l = length( vec3(coord,0.0) - position );
	if ( l < radius  ){
		mediump vec3 shading = ( vec3( coord, 0.0 ) - position ) / radius;
		shading.z = 1.0 - length( shading );
		mediump float intensity = dot( shading, vec3( -0.707, 0.707, 0.4 ) );
		if ( intensity < 0.0 ) intensity *= -1.5;
		color *= intensity + 1.0;
		color += pow( intensity, 3.0 );
		if (l > radius * 0.95){
			color *= 1.0 - ( l - radius * 0.95 ) / ( radius * 0.05);
		}
		result = vec4( color, 1.0 );
	} else {
		mediump vec3 streak = vec3( coord, 0.0 ) - position + vec3( -0.707, 0.707, 0.0 ) * radius * 5.0;
		mediump float value = dot( normalize(streak), vec3( -0.707, 0.707, 0.0 ) ) ;
		mediump float l = length( streak );
		mediump float amount = max( 0.0, value * pow( 10.0 / l*radius, 2.0 ) );
		if(value > 0.98 && l > radius * 5.0){
			amount *= min( 1.0, ( value - 0.98 ) / 0.02 * 5.0);
			color = vec3( -0.01, -0.01, -0.01 ) * amount;
			color *= ( bubble + 1.0 ) / NUM_BUBBLES * 0.8 + 0.2;
			result = vec4( color, 1.0 );
		}
	}
	return result;
}

const float LAYERS = 4.0;
const float SPEED = 0.0005;
const float SCALE = 1000.0;
const float DENSITY	= 0.9;
const float BRIGHTNESS = 10.0;
const float TWIST = 0.04;
const vec3  PALETTE	= vec3(1.0, 1.0, 1.0);
mediump float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }

void main(void) {
	mediump vec2 xy = 1.0-gl_FragCoord.xy / resolution;
	mediump vec4 tx = texture2D(texture0, xy);
//	gl_FragColor =  vec4(tx.xyz, 1.0);
//	return;
	if (index == 0) { // bubbles
    mediump vec2 cPos = -0.8 + 2.0 * xy;
		mediump float cLength = length(cPos);
		mediump float i = clamp(cos(cLength*12.0-time*4.0)/4. + 1.75,0.0,1.0);
		mediump vec2 uv = xy+(cPos/cLength)*cos(cLength*12.0-time*4.0)*0.012;
		mediump vec3 col = texture2D(texture0,uv).xyz * vec3(i);

		mediump vec4 result = vec4(col,1.0); //vec4(0.0);// 0.69, 0.89, 0.99, 1.0 );
		mediump vec2 coord = (xy-0.5)*vec2(2.0*resolution.y/resolution.x,2.0);
		//coord.y=1.0-coord.y;
		for( mediump float i = 0.0; i < NUM_BUBBLES; i += 1.0 ){
			result += doBubble( coord.xy,  i );
		}
		gl_FragColor = result;
    }

  else if (index == 1) { // rippling water
  	mediump vec2 cPos = -0.8 + 2.0 * xy;
		mediump float cLength = length(cPos);
		mediump float i = clamp(cos(cLength*12.0-time*4.0)/4. + 1.75,0.0,1.0);
		mediump vec2 uv = xy+(cPos/cLength)*cos(cLength*12.0-time*4.0)*0.012;
		mediump vec3 col = texture2D(texture0,uv).xyz * vec3(i);

		gl_FragColor = vec4(col,1.0);
	}
	else if (index == 2)	{
		mediump vec2 position = ( gl_FragCoord.xy / resolution ) - vec2(0.0, 0.5);
		highp float waves = sin(position.x*10.0)*0.02*sin(time*10.0)   +  sin(position.x*10.0+1.3)*0.015*sin(time*10.0+10.5);
		mediump float color = 0.0;
		waves -= 0.5 - 0.7;

		if (position.y < waves)	{
		 	color = (waves-position.y)*20.0;
			color = min(pow(color,0.5),1.0);
			mediump vec4 colour = vec4( position.y < waves ? mix(vec3(0.59,0.63,0.86),vec3(0.19,0.24,0.51),color) : vec3(0,0,0), 1.0 );
			gl_FragColor = vec4((colour.x*4.+tx.x)/5., (colour.y+tx.y)/2., (colour.z+tx.z)/2.0, 1.0);
		}
		else
			gl_FragColor = tx; //vec4(tx, 1.0);
	}

	else if (index == 3) { // fire
	    mediump float col = 0.0;
	    if (xy.y > 0.5)
	    {
			vec2 p=(gl_FragCoord.xy/resolution.y)*10.0;
			p.y-=resolution.x/resolution.y*1.5;
			p.x+=1.5;
			float dist,fx;

		 	col=-p.y/2.0+fbm(p);
		}
		else
			col = 0.0;

		if (col < 0.1)
			gl_FragColor = vec4(tx.x*1.8, tx.y, tx.z, 1.0);
		else
			gl_FragColor = vec4(col*4.0,col*2.0,col,1.0);
	}

	else if (index == 4) { // flaming star
	    vec2 p = xy - vec2(0.45,0.5);

		float color = 3.5 - (3.*length(2.*p));

		vec3 coord = vec3(atan(p.x,p.y)/Tau+.5, length(p)*.4, .5);

		for(int i = 1; i <= 2; i++)
		{
			float power = pow(2.0, float(i));
			color += (1.5 / power) * snoise(coord + vec3(0.,-time*.05, time*.01), power*16.);
		}

		float blend = clamp(1.0-length(p)*3., 0.0, 1.0);
		vec3 tx3 = vec3( color, pow(max(color,0.),2.)*0.4, pow(max(color,0.),3.)*0.15);
		tx3 = clamp(tx3, 0.0, 1.0);
		tx.x *= 1.8;
		gl_FragColor = vec4(tx.xyz * blend + tx3 * length(p), 1.0);
	}
	else if (index == 5) { // snow
		highp vec2 pos = gl_FragCoord.xy - vec2(resolution.x*2.0,resolution.y);;
		pos.x = 1.0 - pos.x;
		mediump float dist = length(pos) / resolution.y;
		mediump vec2 coord = vec2(pow(dist, 0.1), 1.0-atan(pos.y, pos.x) / Tau);
		mediump vec3 color = vec3(0.0);
		for (float i = 0.0; i < LAYERS; ++i)
		{
			mediump float t = i*10.0 + time*i*i;
			mediump float r = coord.y - (t*SPEED);
			mediump float c = fract(sin(time*.1+i)*TWIST + xy.x + i*.125);
			mediump vec2  p = vec2(r, c*.5);
			mediump vec2 uv = fract(p*SCALE);
			mediump float a = 1.0-length(uv*2.0-1.0);
			mediump vec3  m = fract(r*SCALE * PALETTE)+i*.2;
			mediump float d = (rand(floor(p*SCALE))-DENSITY)*BRIGHTNESS;
			d = clamp(d*dist, 0.0, 1.0);
			color = max(color, a*m*d);
		}
		tx.z *= 1.8;
		tx.x *= 0.7;
		gl_FragColor =  vec4(tx.xyz + color, 1.0);
	}
		else if (index == 6) { // rain
		highp vec2 pos = gl_FragCoord.xy - vec2(resolution.x*2.0,resolution.y);;
		pos.x = 1.0 - pos.x;
		mediump float dist = length(pos) / resolution.y;
		mediump vec2 coord = vec2(pow(dist, 0.1), 1.0-atan(pos.y, pos.x) / Tau);
		mediump vec3 color = vec3(0.0);
		for (float i = 4.0; i < 5.0; ++i)
		{
			mediump float t = i*10.0 + time*i*i;
			mediump float r = coord.y - (t*SPEED*4.0);
			mediump float c = fract(xy.x + i*.125);
			mediump vec2  p = vec2(r, c*.5);
			mediump vec2 uv = fract(p*SCALE*1.5);
			mediump float a = 1.0-length(uv*2.0-1.0);
			mediump vec3  m = fract(r*SCALE*1.5 * PALETTE)+i*.2;
			mediump float d = (rand(floor(p*SCALE*1.5))-0.97)*BRIGHTNESS;
			d = clamp(d*dist, 0.0, 1.0);
			color = max(color, a*m*d)/2.0;
		}
		tx.z *= 1.4;
		tx.x *= 0.8;
		gl_FragColor =  vec4(tx.xyz + color, 1.0);
	}
}
</script>


	<script id="shader-vs" type="v">
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec2 vTextureCoord;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord;
    }
</script>
</head>

<div id="container">
	<portraitCover>
		<smartphone display="none"></smartphone>
	</portraitCover>
	<div id="main">
		<canvas id="webgl-canvas" top="0"></canvas>
		<div id="no-camera">No Webcam!</div>
		<div id="close-button">x</div>
		<splash class="btn" enabled id="splash"></splash>
		<svgpanel class="canvas" enabled>
			<svg height="100%" width="100%"></svg>
		</svgpanel>
		<panel id=class="img" enabled> </panel>
		<button class="btn" enabled></button>
		<button1 class="btn" enabled></button1>
		<button2 class="btn" enabled></button2>
		<button3 class="btn" enabled></button3>
		<button4 class="btn" enabled></button4>
		<button5 class="btn" enabled></button5>
		<button6 class="btn" enabled></button6>
		<button7 class="btn" enabled></button7>
		<next class="btn" hidden enabled></next>
		<back class="btn" hidden enabled></back>
		<progress value="0" max="100" id="progress"></progress>
		<settings class="btn" hidden></settings>
	</div>
</div>
</body>

</html>